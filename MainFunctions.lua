local Trove = loadstring(game:HttpGet('https://github.com/Sleitnick/RbxUtil/blob/main/modules/trove/init.lua'))()
local TableUtil = loadstring(game:HttpGet('https://github.com/Sleitnick/RbxUtil/blob/main/modules/table-util/init.lua'))()

local LocalPlayer = game:GetService("Players").LocalPlayer

local StarterGui = game:GetService("StarterGui")
local HttpService = game:GetService("HttpService")

local BackpackRemote = game:GetService("ReplicatedStorage").Remotes.Backpack
local ObjectInteractRemote = game:GetService("ReplicatedStorage").Remotes.ObjectInteract
local ToolActionRemote = game:GetService("ReplicatedStorage").Remotes.ToolAction
local CraftRemote = game:GetService("ReplicatedStorage").Remotes.Craft

local PickupRemote = game:GetService("ReplicatedStorage").Remotes.Pickup
local DropRemote = game:GetService("ReplicatedStorage").Remotes.Drop

local GetDataRemote = game:GetService("ReplicatedStorage").Remotes.GetData
local GetMaterialsRemote = game:GetService("ReplicatedStorage").Remotes.GetMaterials

local PlayerData = nil
local PlayerMaterials = nil

local Functions = {}

writefile("Icon096.png", game:HttpGet("https://tr.rbxcdn.com/27f78caa77d4c3aaeae813fec7f86adf/150/150/Image/Png"))
local IconNotify = getcustomasset("Icon096.png")

function Functions.Teleport(newCFrame, unsit)
    local character = LocalPlayer.Character
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")
    if not humanoid then
        return false
    end
    
    local hipHeight = humanoid and humanoid.HipHeight > 0 and (humanoid.HipHeight + 1)
    local rootPart = character.PrimaryPart

    if not character.PrimaryPart then
        return false
    end
    
    character:PivotTo(newCFrame)
end

function Functions.Notify(customText)
    StarterGui:SetCore("SendNotification", {
		Title = "SCP-096 Exploit",
		Text = customText,
		Icon = IconNotify,
		Duration = 5
	})
end

function Functions.GetPlayerMaterials()
    return PlayerMaterials
end

function Functions.UpdatePlayerMaterials()
    local InvokeReturn = GetMaterialsRemote:InvokeServer()

    if (InvokeReturn) then
        PlayerMaterials = InvokeReturn
    end

    return InvokeReturn
end

function Functions.GetPlayerData()
    return PlayerData
end

function Functions.UpdatePlayerData()
    local InvokeReturn = GetDataRemote:InvokeServer()

    if (InvokeReturn) then
        PlayerData = InvokeReturn
    end

    return InvokeReturn
end

function Functions.GetBackpackItems(backpack)
    backpack = backpack or PlayerData.Backpack

    local items = TableUtil.Filter(backpack, function(value, key)
        return value[1] ~= "None"
    end)

    return items
end

function Functions.GetItemAmount(name, backpack)
    local amount = 0

    for _, itemTable in ipairs(Functions.GetBackpackItems(backpack)) do
        if (name ~= "Any" and itemTable[1] ~= name) then
            continue
        end
        
        amount = amount + itemTable[2]
    end

    return amount
end

function Functions.DropItem(name)
    local SavedAmount = Functions.GetItemAmount(name)

    if (SavedAmount == 0) then
        Functions.Notify("You don't have items to drop")
        return false
    end

    local args = {
        [1] = "Drop",
        [2] = name
    }  

    repeat
        BackpackRemote:FireServer(unpack(args))
        Functions.UpdatePlayerData()
    until SavedAmount > Functions.GetItemAmount(name)

    return true
end

function Functions.GetBackpackSlots()
    return LocalPlayer:GetAttribute("BackpackSlots")
end

function Functions.CanSaveItem(pathToItem)
    local BackpackAmount = Functions.GetItemAmount("Any")
    local ItemAmount = 0

    if (pathToItem:GetAttribute("Type") == "Food") then
        ItemAmount = 1
    elseif (pathToItem:GetAttribute("Type") == "Tool") then
        ItemAmount = 4
    else
        return false
    end

    if (BackpackAmount + ItemAmount) > LocalPlayer:GetAttribute("BackpackSpace") then
        return false
    end

    local Backpack = Functions.GetBackpackItems()

    if (#Backpack >= Functions.GetBackpackSlots()) then
        if ItemAmount == 4 then
            return false
        end

        local ExistingItems = Functions.GetItemAmount(pathToItem.Name)

        if ExistingItems == 0 then
            return false
        end
    end

    return true
end

function Functions.SaveItem(pathToItem)
    if (pathToItem == nil or pathToItem.Parent == nil) then
        return false
    end

    if not Functions.CanSaveItem(pathToItem) then
        return false
    end

    local args = {
        [1] = pathToItem
    }

    local newPos = pathToItem:GetPivot().Position

    local SavedItems = Functions.GetBackpackItems()

    repeat
        Functions.Teleport(CFrame.new(newPos))
        ObjectInteractRemote:FireServer(unpack(args))
        
        Functions.UpdatePlayerData()
    until #Functions.GetBackpackItems() > #SavedItems or pathToItem == nil or pathToItem.Parent == nil

    return true
end

function Functions.Pickup(pathToObject)
    if (pathToObject == nil) then
        Functions.Notify("Object does not exist")
        return false
    end

    if (pathToObject:GetAttribute("Owner") ~= nil and pathToObject:GetAttribute("Owner") ~= LocalPlayer.UserId) then
        Functions.Notify("You don't own this object")
        return false
    end

    if (pathToObject:GetAttribute("PickedUp") == true) then
        Functions.Notify("Object is already picked up")
        return false
    end

    local args = {
        [1] = pathToObject
    }

    local newPos = pathToObject:GetPivot().Position
    
    repeat
        Functions.Teleport(CFrame.new(newPos))   
        PickupRemote:FireServer(unpack(args))
        wait()
    until pathToObject:GetAttribute("PickedUp") == true

    return true
end

function Functions.PlaceDrop(position, orientation, sticky)
    local args = {
        [1] = position,
        [2] = orientation,
        [3] = sticky
    }
    
    return DropRemote:InvokeServer(unpack(args))
end

function Functions.Equip(nameTool)
    Functions.UpdatePlayerData()

    if PlayerData.Wearing.Tool ~= "None" then
        Functions.Notify("You are using a different tool")
        return false
    end

    if Functions.GetItemAmount(nameTool) < 4 then
        Functions.Notify("You don't have this tool")
        return false
    end
   
    local args = {
        [1] = "Equip",
        [2] = nameTool,
        [3] = "Tool"
    }

    repeat
        BackpackRemote:FireServer(unpack(args))
        task.wait()
        Functions.UpdatePlayerData()
    until PlayerData.Wearing.Tool == nameTool

    return true
end

function Functions.Unequip()
    Functions.UpdatePlayerData()

    if PlayerData.Wearing.Tool == "None" then
        return false
    end

    local args = {
        [1] = "Unequip",
        [2] = PlayerData.Wearing.Tool,
        [3] = "Tool"
    }

    repeat
        BackpackRemote:FireServer(unpack(args))
        task.wait()
        Functions.UpdatePlayerData()
    until PlayerData.Wearing.Tool == "None"

    return true
end

function Functions.UseTool(...)
    if PlayerData.Wearing.Tool == "None" then
        return false
    end

    ToolActionRemote:FireServer(unpack({...}))

    return true
end

function Functions.IsCraftable(objectName)
    for _, v in ipairs(game:GetService("ReplicatedStorage").Craftable:GetChildren()) do
        if v.Name == objectName then
            return true
        end
    end

    return false
end

function Functions.Craft(objectName)
    if not Functions.IsCraftable(objectName) then
        Functions.Notify("This object can't be crafted")
        return false
    end

    Functions.UpdatePlayerMaterials()

    local ObjectTemplate = game:GetService("ReplicatedStorage").Craftable:FindFirstChild(objectName)
    local ObjectMaterials = {}

    for _, materialObj in ipairs(ObjectTemplate.Mats:GetChildren()) do
        ObjectMaterials[materialObj.Name] = materialObj.Value
    end

    local hasAllMaterials = TableUtil.Every(ObjectMaterials, function(amount, material)
        return Functions.GetPlayerMaterials()["Owned"][material] >= amount
    end)

    if not hasAllMaterials then
        Functions.Notify("You don't have enough materials")
        return false
    end

    local args = {
        [1] = objectName
    }

    local newCraft = nil

    if ObjectTemplate:GetAttribute("Type") == "Tool" then
        Functions.UpdatePlayerData()

        local SavedItemAmount = Functions.GetItemAmount(objectName)
        local AmountBackpack = Functions.GetItemAmount("Any", SavedBackpack)

        if AmountBackpack + 4 > 30 then
            Functions.Notify("Backpack is full")
            return false
        end

        task.spawn(function()
            while true do
                local NewBackpack = Functions.GetPlayerData().Backpack

                if Functions.GetItemAmount(objectName, NewBackpack) > SavedItemAmount  then
                    newCraft = true
                    break
                end

                Functions.UpdatePlayerData()
                task.wait()
            end
        end)
    else
        local TroveObject = Trove.new()

        TroveObject:Connect(game:GetService("Workspace").Interact.ChildAdded, function(child) 
            if newCraft ~= nil then
                return
            end
        
            if child.Name == objectName.." ["..LocalPlayer.Name.."]" then
                newCraft = child
                TroveObject:Clean()
                return
            end
        end)
    end
    
    CraftRemote:FireServer(unpack(args))

    repeat
        task.wait()
    until newCraft ~= nil

    return newCraft
end

return Functions