
local LocalPlayer = game:GetService("Players").LocalPlayer
local HttpService = game:GetService("HttpService")

local GetDataRemote = game:GetService("ReplicatedStorage").Remotes.GetData
local BackpackRemote = game:GetService("ReplicatedStorage").Remotes.Backpack
local ObjectInteractRemote = game:GetService("ReplicatedStorage").Remotes.ObjectInteract

local PickupRemote = game:GetService("ReplicatedStorage").Remotes.Pickup
local DropRemote = game:GetService("ReplicatedStorage").Remotes.Drop

local Data;

function UpdateData() 
    local InvokeReturn = game:GetService("ReplicatedStorage").Remotes.GetData:InvokeServer()

    if (InvokeReturn) then
        Data = InvokeReturn
    end

    return InvokeReturn
end

function GetBackpackItems(backpack)
    backpack = backpack or Data.Backpack
    items = {}

    for _, itemTable in pairs(backpack) do
        if (itemTable[1] ~= "None") then
            table.insert(items, itemTable)
        end
    end

    return items
end

function GetItemAmount(name)
    local amount = 0

    for i, itemTable in ipairs(GetBackpackItems()) do
        if (itemTable[1] == name) then
            amount = amount + itemTable[2]
        end
    end

    return amount
end

function DropItem(name)
    local SavedAmount = GetItemAmount(name)

    if (SavedAmount == 0) then
        return false
    end

    local args = {
        [1] = "Drop",
        [2] = name
    }

    print(name)    

    repeat
        BackpackRemote:FireServer(unpack(args))
        UpdateData()
        print(SavedAmount)
        print(GetItemAmount(name))
    until SavedAmount > GetItemAmount(name)

    return true
end

function SaveItem(pathToItem)
    if (pathToItem == nil or pathToItem.Parent == nil) then
        return false
    end

    local ItemCFrame = pathToItem.PrimaryPart.CFrame

    local TotalPoints = 0
    local ItemPoints = 0

    if (pathToItem:GetAttribute("Type") == "Food") then
        ItemPoints = 1
    elseif (pathToItem:GetAttribute("Type") == "Tool") then
        ItemPoints = 4
    else
        return false
    end
    
    local SavedItems = GetBackpackItems()

    for _, itemTable in ipairs(SavedItems) do
        if (itemTable[2]) then
            TotalPoints = TotalPoints + itemTable[2]
        end
    end
    
    if ((TotalPoints + ItemPoints) > 30) then
        return false
    end

    if (#SavedItems >= 6) then
        local Flag = false

        for _, itemTable in ipairs(SavedItems) do
            if (itemTable[1] == pathToItem.Name and ItemPoints == 1) then
                Flag = true
            end
        end

        if (not Flag) then
            return false
        end
    end

    local args = {
        [1] = pathToItem
    }

    repeat
        LocalPlayer.Character.HumanoidRootPart.CFrame = ItemCFrame
        ObjectInteractRemote:FireServer(unpack(args))
        
        UpdateData()
    until #GetBackpackItems() > #SavedItems or pathToItem == nil or pathToItem.Parent == nil

    return true
end

function UIDropItems(limit)
    limit = limit or math.huge

    local dropAmount = 0

    local TypeSearch = ObjConfig.Type
    local NameSearch = ObjConfig.Name

    for _, itemTable in ipairs(GetBackpackItems()) do
        if (dropAmount >= limit) then
            break
        end

        local name = itemTable[1]
        local itemAmount = itemTable[2]

        local modelItem = game:GetService("ReplicatedStorage").Foods:FindFirstChild(name)

        if NameSearch ~= "Any" and name ~= NameSearch  then
            continue
        end

        if TypeSearch ~= "Any" and modelItem:GetAttribute("Type") ~= TypeSearch  then
            continue
        end

        while (itemAmount >= 1 and dropAmount < limit) do
            if (DropItem(name) == true) then
                itemAmount -= 1
                dropAmount += 1
            else
                break
            end
        end
    end
end

function UIGetItems(limit)
    local HumanoidRootPart = LocalPlayer.Character.HumanoidRootPart
    local SavedCFrame = LocalPlayer.Character.HumanoidRootPart.CFrame

    local bg = Instance.new("BodyGyro", HumanoidRootPart) 
    bg.P = 9e4 
    bg.maxTorque = Vector3.new(9e9, 9e9, 9e9) 
    bg.cframe = HumanoidRootPart.CFrame 
    local bv = Instance.new("BodyVelocity", HumanoidRootPart) 
    bv.velocity = Vector3.new(0,0.1,0) 
    bv.maxForce = Vector3.new(9e9, 9e9, 9e9)

    limit = limit or math.huge

    local items = {}

    for _, obj in ipairs(game:GetService("Workspace").Interact:GetChildren()) do
        local objType = obj:GetAttribute("Type")

        if objType == nil or not (objType == "Tool" or objType == "Food") then
            continue
        end

        if ObjConfig.Type ~= "Any" and objType ~= ObjConfig.Type  then
            continue
        end

        if ObjConfig.Name ~= "Any" and obj.Name ~= ObjConfig.Name  then
            continue
        end

        local distance = (LocalPlayer.Character.HumanoidRootPart.Position - obj.PrimaryPart.Position).Magnitude
        table.insert(items, {obj, distance})
    end

    table.sort(items, function(a, b)
        if ObjConfig.PrioritySearch == "Nearest" then
            return a[2] < b[2]
        elseif ObjConfig.PrioritySearch == "Farthest" then
            return a[2] > b[2]
        end
    end)

    local amount = 0

    for _, itemTable in ipairs(items) do
        local obj = itemTable[1]

        if (amount >= limit) then
            break
        end

        if SaveItem(obj) == true then
            amount += 1
        end
    end

    LocalPlayer.Character.HumanoidRootPart.CFrame = SavedCFrame
    bg:Destroy()
    bv:Destroy()
end

function Pickup(pathToObject)
    if (pathToObject:GetAttribute("Owner") ~= nil and pathToObject:GetAttribute("Owner") ~= LocalPlayer.UserId) then
        return false
    end

    local args = {
        [1] = pathToObject
    }
    
    repeat
        LocalPlayer.Character.HumanoidRootPart.CFrame = pathToObject.PrimaryPart.CFrame
        PickupRemote:FireServer(unpack(args))
        wait()
    until pathToObject:GetAttribute("PickedUp") == true
end

function PlaceDrop(position, orientation, sticky)
    local args = {
        [1] = position,
        [2] = orientation,
        [3] = sticky
    }
    
    return DropRemote:InvokeServer(unpack(args))
end