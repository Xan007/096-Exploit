local LocalPlayer = game:GetService("Players").LocalPlayer

local HttpService = game:GetService("HttpService")

local library = loadstring(game:HttpGet(('https://raw.githubusercontent.com/Xan007/096-Exploit/master/libs/Wally.lua')))()
local mainFunctions = loadstring(game:HttpGet(('https://raw.githubusercontent.com/Xan007/096-Exploit/master/MainFunctions.lua')))()

local Trove = loadstring(game:HttpGet(('https://raw.githubusercontent.com/Xan007/096-Exploit/master/utils/Trove.lua')))()
local TableUtil = loadstring(game:HttpGet(('https://raw.githubusercontent.com/Xan007/096-Exploit/master/utils/TableUtil.lua')))()

local MainTrover = Trove.new()
local BuildingTrover = MainTrover:Extend()

local w = library:CreateWindow("096 Exploit")
local uiObjects = w:CreateFolder("Items")
local uiBuilding = w:CreateFolder("Building")

local uiSettings = w:CreateFolder("Settings")
uiSettings:DestroyGui()

function GetListObjects()
    local newObjectList = {"Any"}

    local function insert(v)
        if table.find(newObjectList, v.Name) then
            return
        end

        table.insert(newObjectList, v.Name)
    end

    for _, v in ipairs(game:GetService("Workspace").Interact:GetChildren()) do
        if (string.match(v.Name, "]$") == nil) then
            insert(v)
        end
    end

    for _, v in ipairs(game:GetService("ReplicatedStorage").Foods:GetChildren()) do
        insert(v)
    end

    for _, v in ipairs(game:GetService("ReplicatedStorage").Craftable:GetChildren()) do
        insert(v)
    end

    table.sort(newObjectList, function(a, b)
        return a < b
    end)

    return newObjectList
end

local BuildDropdown = nil

local BuildOptions = {
    Object = "",
    Script = "",
    PrioritySearch = "Farthest"
}

local listObjects = GetListObjects()

uiBuilding:Box("Search", "string", function(search)
    local newList = {}

    if string.match(search, "^%s*$") ~= nil then
        newList = listObjects
    else
        for _, nameObject in ipairs(listObjects) do
            if (string.match(nameObject, search)) then
                table.insert(newList, nameObject)
            end
        end
    end

    BuildDropdown:Refresh(newList)
end)

uiBuilding:Label("Object name", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255);
    BgColor = Color3.fromRGB(30, 30, 30); 
})

BuildDropdown = uiBuilding:Dropdown("Any", listObjects, true, function(opt)
    BuildOptions.Object = opt
end)


uiBuilding:Label("Scripts builds", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255);
    BgColor = Color3.fromRGB(30, 30, 30); 
})

uiBuilding:Dropdown("Any", listfiles("builds"), true, function(opt)
    BuildOptions.Script = opt
end)

uiBuilding:Label("Priority search", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255); 
    BgColor = Color3.fromRGB(30, 30, 30);
})

uiBuilding:Dropdown("Farthest", {"Nearest", "Farthest"}, true, function(opt)
    BuildOptions.PrioritySearch = opt
end)

uiBuilding:Button("Get one", function()
    if (not BuildOptions.Object) then
        return
    end

    StartBuilding({            
        {BuildOptions.Object, {0,0,0}, {0,0,0}}, 
        -15
    })
end)

uiBuilding:Button("Execute build", function()
    if (not BuildOptions.Script) then
        return
    end

    StartBuilding(HttpService:JSONDecode(readfile(BuildOptions.Script)))
end)

uiBuilding:Button("Stop building", function()
    BuildingTrover:Clean()
end)

uiBuilding:Button("Restart CFrames", function()
    for _, model in ipairs(game:GetService("Workspace").Interact:GetChildren()) do
        model:SetAttribute("HackCFrame", nil)
    end
end)


--[[ VARIABLES ]]

local ObjDropdown = nil

local ObjConfig = {
    Type = "Any",
    Name = "Any",
    PrioritySearch = "Nearest"
}

uiObjects:Label("Type of item", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255); 
    BgColor = Color3.fromRGB(30, 30, 30); 
})

function GetListItems(opt)
    local newItemList = {"Any"}

    for _, v in ipairs(game:GetService("ReplicatedStorage").Foods:GetChildren()) do
        if opt ~= "Any" and v:GetAttribute("Type") ~= opt then
            continue
        end

        if table.find(newItemList, v.Name) == nil then
            table.insert(newItemList, v.Name)
        end
    end

    return newItemList
end

uiObjects:Dropdown("Any", {"Any", "Tool", "Food"}, true, function(opt)
    local newObjectList = GetListItems(opt)

    ObjDropdown:Refresh(newObjectList)

    ObjConfig.Type = opt
end)

uiObjects:Label("Item name", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255);
    BgColor = Color3.fromRGB(30, 30, 30); 
})

ObjDropdown = uiObjects:Dropdown("Any", GetListItems("Any"), true, function(opt)
    ObjConfig.Name = opt
end)

uiObjects:Label("Priority search", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255); 
    BgColor = Color3.fromRGB(30, 30, 30);
})

uiObjects:Dropdown("Nearest", {"Nearest", "Farthest"}, true, function(opt)
    ObjConfig.PrioritySearch = opt
end)

uiObjects:Button("Get one", function()
    mainFunctions.UpdateData()
    UIGetItems(1)
end)

uiObjects:Button("Get all", function() 
    mainFunctions.UpdateData()
    UIGetItems()
end)

uiObjects:Button("Drop one", function() 
    mainFunctions.UpdateData()
    UIDropItems(1)
end)

uiObjects:Button("Drop all", function() 
    mainFunctions.UpdateData()
    UIDropItems()
end)

function UIDropItems(limit)
    limit = limit or math.huge

    local dropAmount = 0

    local TypeSearch = ObjConfig.Type
    local NameSearch = ObjConfig.Name

    for _, itemTable in ipairs(mainFunctions.GetBackpackItems()) do
        if (dropAmount >= limit) then
            break
        end

        local name = itemTable[1]
        local itemAmount = itemTable[2]

        local modelItem = game:GetService("ReplicatedStorage").Foods:FindFirstChild(name)

        if NameSearch ~= "Any" and name ~= NameSearch  then
            continue
        end

        if TypeSearch ~= "Any" and modelItem:GetAttribute("Type") ~= TypeSearch  then
            continue
        end

        while (itemAmount >= 1 and dropAmount < limit) do
            if (mainFunctions.DropItem(name) == true) then
                itemAmount -= 1
                dropAmount += 1
            else
                break
            end
        end
    end
end

function UIGetItems(limit)
    limit = limit or math.huge

    local HumanoidRootPart = LocalPlayer.Character.HumanoidRootPart
    local SavedCFrame = HumanoidRootPart.CFrame

    local items = {}

    for _, obj in ipairs(game:GetService("Workspace").Interact:GetChildren()) do
        local objType = obj:GetAttribute("Type")

        if objType == nil or not (objType == "Tool" or objType == "Food") then
            continue
        end

        if ObjConfig.Type ~= "Any" and objType ~= ObjConfig.Type  then
            continue
        end

        if ObjConfig.Name ~= "Any" and obj.Name ~= ObjConfig.Name  then
            continue
        end

        local distance = (SavedCFrame.Position - obj.PrimaryPart.Position).Magnitude
        table.insert(items, {obj, distance})
    end

    table.sort(items, function(a, b)
        if ObjConfig.PrioritySearch == "Nearest" then
            return a[2] < b[2]
        elseif ObjConfig.PrioritySearch == "Farthest" then
            return a[2] > b[2]
        end
    end)

    local amount = 0

    for _, itemTable in ipairs(items) do
        local obj = itemTable[1]

        if (amount >= limit) then
            break
        end

        if mainFunctions.SaveItem(obj) == true then
            amount += 1
        end
    end

    HumanoidRootPart.CFrame = SavedCFrame
end

function GetBuildObjects(name, amount)
    local SavedCFrame = LocalPlayer.Character.HumanoidRootPart.CFrame

    local BuildObjects = {}

    for _, obj in ipairs(game:GetService("Workspace").Interact:GetChildren()) do
        if (#BuildObjects > amount) then
            break
        end

        if (string.match(obj.Name, "^"..name.."$") == nil) then
            continue
        end

        local owner = obj:GetAttribute("Owner")

        if (owner ~= nil and owner ~= LocalPlayer.UserId) then
            continue
        end

        if (obj:GetAttribute("Transparent")) then
            continue
        end

        if (obj:GetAttribute("IgnoreScript")) then
            continue
        end

        if (obj:GetAttribute("HackCFrame")) then
            local HackCFrame = obj:GetAttribute("HackCFrame")

            if obj:GetPivot() == HackCFrame then
                continue
            end
        end

        local distance = (SavedCFrame.Position - obj.PrimaryPart.Position).Magnitude
        table.insert(BuildObjects, {obj, distance})
    end

    table.sort(BuildObjects, function(a, b)
        if BuildOptions.PrioritySearch == "Nearest" then
            return a[2] < b[2]
        elseif BuildOptions.PrioritySearch == "Farthest" then
            return a[2] > b[2]
        end
    end)

    return TableUtil.Map(BuildObjects, function(value)
        return value[1]
    end)
end

function SetTransparency(obj, number, exclude)
    if (obj:IsA("Model")) then
        for _, v in ipairs(obj:GetDescendants()) do
            if v:IsA("BasePart") then
                SetTransparency(v, number, exclude)
            end
        end
    elseif (obj:IsA("BasePart")) then
        if (exclude and table.find(exclude, obj.Name)) then
            return
        end

        obj.Transparency = number
        obj.CanCollide = false
    end
end

function StartBuilding(dataBuild)
    BuildingTrover:Clean()
    local FunctionTrove = BuildingTrover:Extend()
    local ModelTrove = BuildingTrover:Extend()

    local SavedCFrame = nil

    local dataOffset = table.remove(dataBuild, #dataBuild)

    local CenterCFrame = game.Workspace.CurrentCamera.CFrame

    local TemplateModel = Instance.new("Model", game.Workspace)
    TemplateModel.Name = "Template"
    TemplateModel:PivotTo(CFrame.new((CenterCFrame * CFrame.new(0,0, dataOffset)).Position))

    ModelTrove:Add(TemplateModel)

    local BuildMaterials = {}

    for _, data in ipairs(dataBuild) do
        local materialName = data[1]
        local DataPosition = Vector3.new(unpack(data[2]))
	    local DataRotation = CFrame.new(unpack(data[3]))

        local buildObject = unpack(GetBuildObjects(materialName, 1))

        if (not buildObject) then
            break
        end

        local NewPos = CFrame.new((TemplateModel:GetPivot()).Position):PointToWorldSpace(DataPosition)        

        local cloneObject = buildObject:Clone()
        cloneObject.Parent = TemplateModel
        cloneObject.PrimaryPart.Anchored = true
        SetTransparency(cloneObject, 0.5, {"Hitbox"})

        cloneObject:PivotTo(CFrame.new(NewPos) *  (DataRotation))
        cloneObject:SetAttribute("IgnoreScript", true)

        buildObject:SetAttribute("IgnoreScript", true)
        FunctionTrove:Add(function()
            buildObject:SetAttribute("IgnoreScript", false)
        end)

        table.insert(BuildMaterials, {buildObject, cloneObject})
    end

    if (#BuildMaterials < #dataBuild) then
        FunctionTrove:Clean()
        ModelTrove:Clean()
        return
    end
    
    FunctionTrove:Connect(game:GetService("UserInputService").InputChanged, function(input)
        if (input.UserInputType == Enum.UserInputType.MouseWheel) then
            local Rotation = input.Position.Z

            dataOffset -= Rotation
        end
    end)

    local CurrentRotation = "X"

    local ResetRotation = TemplateModel:GetPivot().Rotation
    local NewRotation = ResetRotation

    FunctionTrove:Connect(game:GetService("UserInputService").InputBegan, function(input)
        if (input.KeyCode == Enum.KeyCode.E) then
            FunctionTrove:Clean()

            SavedCFrame = LocalPlayer.Character.HumanoidRootPart.CFrame

            Build()
            ModelTrove:Clean()
        elseif (input.KeyCode == Enum.KeyCode.One) then
            CurrentRotation = "X"
        elseif (input.KeyCode == Enum.KeyCode.Two) then
            CurrentRotation = "Y"
        elseif (input.KeyCode == Enum.KeyCode.Three) then
            CurrentRotation = "Z"
        elseif (input.KeyCode == Enum.KeyCode.R) then
            if (CurrentRotation == "X") then
                NewRotation = NewRotation * CFrame.fromEulerAnglesXYZ(math.rad(15), 0, 0)
            elseif (CurrentRotation == "Y") then
                NewRotation = NewRotation * CFrame.fromEulerAnglesXYZ(0, math.rad(15), 0)
            elseif (CurrentRotation == "Z") then
                NewRotation = NewRotation * CFrame.fromEulerAnglesXYZ(0, 0, math.rad(15))
            end
        elseif (input.KeyCode == Enum.KeyCode.X) then
            NewRotation = ResetRotation
        end
    end)

    FunctionTrove:BindToRenderStep("Update"..tostring(math.random()), Enum.RenderPriority.Last.Value, function()
        CenterCFrame = game.Workspace.CurrentCamera.CFrame
        TemplateModel:PivotTo(
            CFrame.new((CenterCFrame * CFrame.new(0,0, dataOffset)).Position)
            * NewRotation
        )
    end)

    function Build()
        ModelTrove:Add(function()
            LocalPlayer.Character.HumanoidRootPart.CFrame = SavedCFrame
            LocalPlayer.Character.HumanoidRootPart.AssemblyAngularVelocity = Vector3.new(0,0,0)
            LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(0,0,0)
        end)
        for i, data in ipairs(dataBuild) do
            if (TemplateModel == nil) then
                break
            end

            local buildObject, cloneObject = unpack(BuildMaterials[i])
    
            local NewPos = cloneObject:GetPivot().Position
            local Rotation = cloneObject:GetPivot().Rotation
    
            --Place if something's picked up
            mainFunctions.PlaceDrop(Vector3.new(), CFrame.new(), true)
            local dropReturn = "NO OBJECT"

            while dropReturn ~= true do
                print(dropReturn)
                if dropReturn == false then
                    --Return to its original position
                    mainFunctions.PlaceDrop(buildObject:GetPivot().Position, buildObject:GetPivot().Rotation, true)
                    break
                elseif dropReturn == "NO OBJECT" then
                    mainFunctions.Pickup(buildObject)

                    dropReturn = mainFunctions.PlaceDrop(NewPos, Rotation, true)
                end
                task.wait()
            end

            if (dropReturn ~= true) then
                break
            end

            buildObject:SetAttribute("HackCFrame", buildObject:GetPivot())
        end
    end
end



--TO DO:

--Farming wood, stone
--[[
    SCRIPT FOR EQUIPMENT

    local args = {
        [1] = "Equip",
        [2] = "Wood Axe",
        [3] = "Tool"
    }

    game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Backpack"):FireServer(unpack(args))
]]

--[[
    SCRIPT FOR DESEQUIPMENT
    local args = {
        [1] = "Unequip",
        [2] = "Wood Axe",
        [3] = "Tool"
    }

    game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Backpack"):FireServer(unpack(args))
]]

--[[
    TOOLS ARE SAVED SERVER-SIDE IN

    game:GetService("Workspace").Tools

    weld constraint is 

    game:GetService("Workspace").Tools["412653139"].WeldConstraint

    KNOWING THE TOOL'S OWNER IS AS SIMPLE AS GETTING PART 0 OR PART 1 OF WELDCONSTRAINT
]]

--[[
    SCRIPT FOR USING TOOLS
    game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("ToolAction"):FireServer()
]]

--[[
    PATH WHERE TREES AND STONES ARE
    game:GetService("Workspace").Decoration
]]

