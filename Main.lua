local LocalPlayer = game:GetService("Players").LocalPlayer

local HttpService = game:GetService("HttpService")

local library = loadstring(game:HttpGet(('https://raw.githubusercontent.com/Xan007/096-Exploit/master/libs/Wally.lua'), true))()
local mainFunctions = loadstring(game:HttpGet(('https://raw.githubusercontent.com/Xan007/096-Exploit/master/MainFunctions.lua'), true))()

local Trove = loadstring(game:HttpGet(('https://raw.githubusercontent.com/Xan007/096-Exploit/master/utils/Trove.lua'), true))()
local TableUtil = loadstring(game:HttpGet(('https://raw.githubusercontent.com/Xan007/096-Exploit/master/utils/TableUtil.lua'), true))()

local MainTrover = Trove.new()
local BuildingTrover = MainTrover:Extend()
local FarmingTrover = MainTrover:Extend()

local w = library:CreateWindow("096 Exploit")
local uiObjects = w:CreateFolder("Items")
local uiBuilding = w:CreateFolder("Building")
local uiFarming = w:CreateFolder("Farming")

local uiSettings = w:CreateFolder("Settings")
uiSettings:DestroyGui()

local FarmOptions = {
    TypeFarm = "Wood"
}

uiFarming:Label("Type of farming", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255);
    BgColor = Color3.fromRGB(30, 30, 30); 
})

uiFarming:Dropdown("Wood", {"Wood", "Stone"}, true, function(opt)
    FarmOptions.TypeFarm = opt
end)

uiFarming:Button("Start Farming", function()
    StartFarming(FarmOptions.TypeFarm)
end)

uiFarming:Button("Stop Farming", function()
    StopFarming()
end)

function GetListObjects()
    local newObjectList = {"Any"}

    local function insert(v)
        if table.find(newObjectList, v.Name) then
            return
        end

        table.insert(newObjectList, v.Name)
    end

    for _, v in ipairs(game:GetService("Workspace").Interact:GetChildren()) do
        if (string.match(v.Name, "]$") == nil) then
            insert(v)
        end
    end

    for _, v in ipairs(game:GetService("ReplicatedStorage").Foods:GetChildren()) do
        insert(v)
    end

    for _, v in ipairs(game:GetService("ReplicatedStorage").Craftable:GetChildren()) do
        insert(v)
    end

    table.sort(newObjectList, function(a, b)
        return a < b
    end)

    return newObjectList
end

local BuildDropdown = nil

local BuildOptions = {
    Object = "",
    Script = "",
    PrioritySearch = "Farthest"
}

local listObjects = GetListObjects()

uiBuilding:Box("Search", "string", function(search)
    local newList = {}

    if string.match(search, "^%s*$") ~= nil then
        newList = listObjects
    else
        for _, nameObject in ipairs(listObjects) do
            if (string.match(nameObject, search)) then
                table.insert(newList, nameObject)
            end
        end
    end

    BuildDropdown:Refresh(newList)
end)

uiBuilding:Label("Object name", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255);
    BgColor = Color3.fromRGB(30, 30, 30); 
})

BuildDropdown = uiBuilding:Dropdown("Any", listObjects, true, function(opt)
    BuildOptions.Object = opt
end)


uiBuilding:Label("Scripts builds", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255);
    BgColor = Color3.fromRGB(30, 30, 30); 
})

local buildFiles = uiBuilding:Dropdown("Any", listfiles("SCP-096/builds"), true, function(opt)
    BuildOptions.Script = opt
end)

uiBuilding:Button("Update", function()
    buildFiles:Refresh(listfiles("SCP-096/builds"))
end)

uiBuilding:Label("Priority search", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255); 
    BgColor = Color3.fromRGB(30, 30, 30);
})

uiBuilding:Dropdown("Farthest", {"Nearest", "Farthest"}, true, function(opt)
    BuildOptions.PrioritySearch = opt
end)

uiBuilding:Button("Get one", function()
    if (not BuildOptions.Object) then
        return
    end

    StartBuilding({            
        {BuildOptions.Object, {0,0,0}, {0,0,0}}, 
        -15
    })
end)

uiBuilding:Button("Execute build", function()
    if (not BuildOptions.Script) then
        return
    end

    StartBuilding(HttpService:JSONDecode(readfile(BuildOptions.Script)))
end)

uiBuilding:Button("Stop building", function()
    BuildingTrover:Clean()
end)

uiBuilding:Button("Restart CFrames", function()
    for _, model in ipairs(game:GetService("Workspace").Interact:GetChildren()) do
        model:SetAttribute("HackCFrame", nil)
    end
end)

uiBuilding:Button("ReturnAllMaterials", function()
    ReturnAllMaterials()
end)

--[[ VARIABLES ]]

local ObjDropdown = nil

local ObjConfig = {
    Type = "Any",
    Name = "Any",
    PrioritySearch = "Farthest"
}

uiObjects:Label("Type of item", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255); 
    BgColor = Color3.fromRGB(30, 30, 30); 
})

function GetListItems(opt)
    local newItemList = {"Any"}

    for _, v in ipairs(game:GetService("ReplicatedStorage").Foods:GetChildren()) do
        if opt ~= "Any" and v:GetAttribute("Type") ~= opt then
            continue
        end

        if table.find(newItemList, v.Name) == nil then
            table.insert(newItemList, v.Name)
        end
    end

    return newItemList
end

uiObjects:Dropdown("Any", {"Any", "Tool", "Food"}, true, function(opt)
    local newObjectList = GetListItems(opt)

    ObjDropdown:Refresh(newObjectList)

    ObjConfig.Type = opt
end)

uiObjects:Label("Item name", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255);
    BgColor = Color3.fromRGB(30, 30, 30); 
})

ObjDropdown = uiObjects:Dropdown("Any", GetListItems("Any"), true, function(opt)
    ObjConfig.Name = opt
end)

uiObjects:Label("Priority search", {
    TextSize = 18; 
    TextColor = Color3.fromRGB(255,255,255); 
    BgColor = Color3.fromRGB(30, 30, 30);
})

uiObjects:Dropdown("Farthest", {"Nearest", "Farthest"}, true, function(opt)
    ObjConfig.PrioritySearch = opt
end)

uiObjects:Button("Get one", function()
    mainFunctions.UpdatePlayerData()
    UIGetItems(1)
end)

uiObjects:Button("Get all", function() 
    mainFunctions.UpdatePlayerData()
    UIGetItems()
end)

uiObjects:Button("Drop one", function() 
    mainFunctions.UpdatePlayerData()
    UIDropItems(1)
end)

uiObjects:Button("Drop all", function() 
    mainFunctions.UpdatePlayerData()
    UIDropItems()
end)

function UIDropItems(limit)
    limit = limit or math.huge

    local dropAmount = 0

    local TypeSearch = ObjConfig.Type
    local NameSearch = ObjConfig.Name

    for _, itemTable in ipairs(mainFunctions.GetBackpackItems()) do
        if (dropAmount >= limit) then
            break
        end

        local name = itemTable[1]
        local itemAmount = itemTable[2]

        local modelItem = game:GetService("ReplicatedStorage").Foods:FindFirstChild(name)

        if NameSearch ~= "Any" and name ~= NameSearch  then
            continue
        end

        if TypeSearch ~= "Any" and modelItem:GetAttribute("Type") ~= TypeSearch  then
            continue
        end

        while (itemAmount >= 1 and dropAmount < limit) do
            if (mainFunctions.DropItem(name) == true) then
                itemAmount -= 1
                dropAmount += 1
            else
                break
            end
        end
    end
end

function UIGetItems(limit)
    limit = limit or math.huge

    local HumanoidRootPart = LocalPlayer.Character.HumanoidRootPart
    local SavedCFrame = HumanoidRootPart.CFrame

    local items = {}

    for _, obj in ipairs(game:GetService("Workspace").Interact:GetChildren()) do
        local objType = obj:GetAttribute("Type")

        if objType == nil or not (objType == "Tool" or objType == "Food") then
            continue
        end

        if ObjConfig.Type ~= "Any" and objType ~= ObjConfig.Type  then
            continue
        end

        if ObjConfig.Name ~= "Any" and obj.Name ~= ObjConfig.Name  then
            continue
        end

        local distance = (SavedCFrame.Position - obj.PrimaryPart.Position).Magnitude
        table.insert(items, {obj, distance})
    end

    table.sort(items, function(a, b)
        if ObjConfig.PrioritySearch == "Nearest" then
            return a[2] < b[2]
        elseif ObjConfig.PrioritySearch == "Farthest" then
            return a[2] > b[2]
        end
    end)

    local amount = 0

    for _, itemTable in ipairs(items) do
        local obj = itemTable[1]

        if (amount >= limit) then
            break
        end

        if not mainFunctions.CanSaveItem(obj) then
            Functions.Notify("Cant save item")
            break
        end

        if mainFunctions.SaveItem(obj) then
            amount += 1
        end
        
    end

    HumanoidRootPart.CFrame = SavedCFrame
end

function GetBuildObjects(name, amount)
    local SavedCFrame = LocalPlayer.Character.HumanoidRootPart.CFrame

    local BuildObjects = {}

    for _, obj in ipairs(game:GetService("Workspace").Interact:GetChildren()) do
        if (#BuildObjects > amount) then
            break
        end

        if name ~= "Any" and string.match(obj.Name, "^"..name) == nil then
            continue
        end

        local owner = obj:GetAttribute("Owner")

        if (owner and owner ~= LocalPlayer.UserId) then
            continue
        end

        if (obj:GetAttribute("Transparent")) then
            continue
        end

        if (obj:GetAttribute("IgnoreScript")) then
            continue
        end

        if (obj:GetAttribute("HackCFrame")) then
            local HackCFrame = obj:GetAttribute("HackCFrame")

            if obj:GetPivot() == HackCFrame then
                continue
            end
        end

        local distance = (SavedCFrame.Position - obj.PrimaryPart.Position).Magnitude
        table.insert(BuildObjects, {obj, distance})
    end

    table.sort(BuildObjects, function(a, b)
        if BuildOptions.PrioritySearch == "Nearest" then
            return a[2] < b[2]
        elseif BuildOptions.PrioritySearch == "Farthest" then
            return a[2] > b[2]
        end
    end)

    return TableUtil.Map(BuildObjects, function(value)
        return value[1]
    end)
end

function GetOwnedObjects(name, amount)
    local OwnedObjects = TableUtil.Filter(GetBuildObjects(name, amount), function(object) 
        return object:GetAttribute("Owner") == LocalPlayer.UserId
    end)

    return OwnedObjects
end

function ReturnAllMaterials()
    mainFunctions.UpdatePlayerData()

    --local SavedCFrame = LocalPlayer.Character:GetPivot()

    local OwnedObjects = GetOwnedObjects("Any", math.huge)

    if #OwnedObjects == 0 then
        return false
    end

    if mainFunctions.GetPlayerData().Wearing.Tool ~= "Hammer" then
        if not mainFunctions.Equip("Hammer") then
            if mainFunctions.Craft("Hammer") then
                mainFunctions.Equip("Hammer")
            else
                mainFunctions.Notify("You don't have a hammer. Failed to auto-craft")
                return false
            end
        end
    end

    for _, obj in ipairs(OwnedObjects) do
        mainFunctions.UseTool(obj.PrimaryPart)
        --mainFunctions.Teleport(obj.PrimaryPart.CFrame)
    end

    mainFunctions.Unequip()

    --LocalPlayer.Character:PivotTo(SavedCFrame)
end

function SetTransparency(obj, number, exclude)
    if (obj:IsA("Model")) then
        for _, v in ipairs(obj:GetDescendants()) do
            if v:IsA("BasePart") then
                SetTransparency(v, number, exclude)
            end
        end
    elseif (obj:IsA("BasePart")) then
        if (exclude and table.find(exclude, obj.Name)) then
            return
        end

        obj.Transparency = number
        obj.CanCollide = false
    end
end

function StartBuilding(dataBuild)
    StopBuilding()
    local BuildingFlag = true

    local BeforeTrove = BuildingTrover:Extend()
    local AfterTrove = BuildingTrover:Extend()

    AfterTrove:Add(function()
        BuildingFlag = false
    end)

    local SavedCFrame = nil

    local dataOffset = table.remove(dataBuild, #dataBuild)

    local CenterCFrame = game.Workspace.CurrentCamera.CFrame

    local TemplateModel = Instance.new("Model", game.Workspace)
    TemplateModel.Name = "Template"
    TemplateModel:PivotTo(CFrame.new((CenterCFrame * CFrame.new(0,0, dataOffset)).Position))

    AfterTrove:Add(TemplateModel)

    local BuildMaterials = {}

    for _, data in ipairs(dataBuild) do
        local materialName = data[1]

        local buildObject = unpack(GetBuildObjects(materialName, 1)) or mainFunctions.Craft(materialName)

        if (not buildObject) then
            break
        end

        buildObject:SetAttribute("IgnoreScript", true)
        BeforeTrove:Add(function()
            buildObject:SetAttribute("IgnoreScript", false)
        end)

        table.insert(BuildMaterials, {buildObject})
    end

    if (#BuildMaterials < #dataBuild) then
        StopBuilding()
        return
    end

    for i, data in ipairs(dataBuild) do
        local DataPosition = Vector3.new(unpack(data[2]))
	    local DataRotation = CFrame.new(unpack(data[3]))

        local buildObject = BuildMaterials[i][1]

        local NewPos = CFrame.new((TemplateModel:GetPivot()).Position):PointToWorldSpace(DataPosition)    

        local cloneObject = buildObject:Clone()
        cloneObject.Parent = TemplateModel
        cloneObject.PrimaryPart.Anchored = true

        local PrimaryPart = cloneObject:FindFirstChildWhichIsA("MeshPart") or cloneObject.PrimaryPart

        cloneObject:PivotTo(CFrame.new(NewPos))
        cloneObject:PivotTo(CFrame.new(NewPos) * (DataRotation * PrimaryPart.CFrame.Rotation:Inverse()))

        SetTransparency(cloneObject, 0.5, {"Hitbox"})
        cloneObject:SetAttribute("IgnoreScript", true)

        table.insert(BuildMaterials[i], cloneObject)
    end
    
    BeforeTrove:Connect(game:GetService("UserInputService").InputChanged, function(input)
        if (input.UserInputType == Enum.UserInputType.MouseWheel) then
            local Rotation = input.Position.Z

            dataOffset -= Rotation
        end
    end)

    local CurrentRotation = "X"

    local ResetRotation = TemplateModel:GetPivot().Rotation
    local NewRotation = ResetRotation

    BeforeTrove:Connect(game:GetService("UserInputService").InputBegan, function(input)
        if (input.KeyCode == Enum.KeyCode.E) then
            BeforeTrove:Clean()
            SavedCFrame = LocalPlayer.Character.HumanoidRootPart.CFrame

            Build()
            AfterTrove:Clean()
        elseif (input.KeyCode == Enum.KeyCode.One) then
            CurrentRotation = "X"
        elseif (input.KeyCode == Enum.KeyCode.Two) then
            CurrentRotation = "Y"
        elseif (input.KeyCode == Enum.KeyCode.Three) then
            CurrentRotation = "Z"
        elseif (input.KeyCode == Enum.KeyCode.R) then
            if (CurrentRotation == "X") then
                NewRotation = NewRotation * CFrame.fromEulerAnglesXYZ(math.rad(15), 0, 0)
            elseif (CurrentRotation == "Y") then
                NewRotation = NewRotation * CFrame.fromEulerAnglesXYZ(0, math.rad(15), 0)
            elseif (CurrentRotation == "Z") then
                NewRotation = NewRotation * CFrame.fromEulerAnglesXYZ(0, 0, math.rad(15))
            end
        elseif (input.KeyCode == Enum.KeyCode.X) then
            NewRotation = ResetRotation
        end
    end)

    BeforeTrove:BindToRenderStep("UpdateTemplate", Enum.RenderPriority.Last.Value, function()
        CenterCFrame = game.Workspace.CurrentCamera.CFrame
        TemplateModel:PivotTo(
            CFrame.new((CenterCFrame * CFrame.new(0,0, dataOffset)).Position)
            * NewRotation
        )
    end)

    function Build()
        AfterTrove:Add(function()
            LocalPlayer.Character.HumanoidRootPart.CFrame = SavedCFrame
            LocalPlayer.Character.HumanoidRootPart.AssemblyAngularVelocity = Vector3.new(0,0,0)
            LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(0,0,0)
        end)
        
        for i, data in ipairs(dataBuild) do
            if not BuildingFlag then
                break
            end

            if (TemplateModel == nil) then
                break
            end

            local buildObject, cloneObject = unpack(BuildMaterials[i])

            if buildObject:GetAttribute("Transparent") then
                StopBuilding()
                break
            end
    
            local NewPos = cloneObject:GetPivot().Position
            local Rotation = cloneObject:GetPivot().Rotation
    
            --Place if something's picked up
            mainFunctions.PlaceDrop(Vector3.new(), CFrame.new(), true)
            local dropReturn = "NO OBJECT"

            repeat
                if dropReturn == "NO OBJECT" then
                    mainFunctions.Pickup(buildObject)

                    dropReturn = mainFunctions.PlaceDrop(NewPos, Rotation, true)
                elseif dropReturn == false then
                    local Pivot = buildObject:GetPivot()

                    mainFunctions.PlaceDrop(Pivot.Position, Pivot.Rotation, true)
                    break
                end

                task.wait()
            until buildObject:GetAttribute("PickedUp") == false or not BuildingFlag

            if (dropReturn == false) then
                break
            end

            buildObject:SetAttribute("HackCFrame", buildObject:GetPivot())
        end
    end
end

function StopBuilding()
    BuildingTrover:Clean()
end

function StartFarming(typeFarm)
    StopFarming()

    local FarmingFlag = true

    FarmingTrover:Add(function() 
        FarmingFlag = false
    end)
    
    local function IsNeededTool(toolName)
        if typeFarm == "Wood" and string.match(toolName, "%sAxe") ~= nil then
            return true
        end

        if typeFarm == "Stone" and string.match(toolName, "%sPickaxe") ~= nil then   
            return true
        end

        return false
    end

    local function GetToolLevel(toolName)
        local Tool = game:GetService("ReplicatedStorage").Craftable:FindFirstChild(toolName)

        if not Tool then
            return false
        end

        local Level = Tool:GetAttribute("Level")

        return Level
    end

    mainFunctions.UpdatePlayerData()

    local ToolName, ToolLevel = nil, 0

    for _, itemData in ipairs(mainFunctions.GetBackpackItems()) do
        local itemName = itemData[1]

        if not IsNeededTool(itemName) then
            continue
        end

        local Level = GetToolLevel(itemName)

        if Level and Level > ToolLevel then
            ToolName = itemName
            ToolLevel = Level
        end
    end

    if IsNeededTool(mainFunctions.GetPlayerData().Wearing.Tool) then
        local EquippedTool = mainFunctions.GetPlayerData().Wearing.Tool
        local Level = GetToolLevel(EquippedTool)

        if Level and Level > ToolLevel then
            ToolName = EquippedTool
            ToolLevel = Level
        else
            mainFunctions.Unequip()
            mainFunctions.UpdatePlayerData()
        end
    end

    if ToolName == nil then
        return false
    end

    if not mainFunctions.Equip(ToolName) and mainFunctions.GetPlayerData().Wearing.Tool ~= ToolName then
        --Can't equip because a tool is already in use
        return false
    end

    local ModelTool = nil

    while not ModelTool or not FarmingFlag do
        ModelTool = game:GetService("Workspace").Tools:FindFirstChild(tostring(LocalPlayer.UserId))
        task.wait()
    end

    local updateTimePassed = 0

    FarmingTrover:BindToRenderStep("CheckEquippedTool", Enum.RenderPriority.Last.Value, function(delta)
        if not FarmingFlag then
            return
        end

        if not ModelTool or not ModelTool:IsDescendantOf(game.Workspace) then
            StopFarming()
        end
    end)

    for _, decoration in ipairs(game:GetService("Workspace").Decoration:GetChildren()) do
        if not FarmingFlag then
            break
        end

        if typeFarm == "Wood" and string.match(decoration.Name, "Tree") == nil then
            continue
        end

        if typeFarm == "Stone" and string.match(decoration.Name, "Stone") == nil then   
            continue
        end
        
        if ModelTool then
            local WeldConstraint = ModelTool:FindFirstChildWhichIsA("WeldConstraint")
            WeldConstraint.Part0 = nil

            ModelTool:PivotTo(decoration:GetPivot())
        end

        repeat
            mainFunctions.Teleport(decoration:GetPivot())
            mainFunctions.UseTool()
            
            task.wait()
        until decoration == nil or decoration.Parent == nil  or FarmingFlag == false
    end

    FarmingTrover:Clean()
end

function StopFarming()
    FarmingTrover:Clean()
end

